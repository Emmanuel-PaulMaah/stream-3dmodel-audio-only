<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>WebXR + WebRTC (PeerJS) — AR cubes + audio</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,body { margin:0; height:100%; overflow:hidden; font-family:system-ui, sans-serif; }
    #ui {
      position: fixed; top: 12px; left: 12px; z-index: 30;
      background: rgba(255,255,255,0.9); padding: 10px; border-radius: 8px; max-width: 92vw;
    }
    #ui p { margin: 0 0 6px 0; font-size: 14px; }
    #ui input { width: 180px; }
    #status { font-size: 12px; opacity: .8; margin-top: 6px; }
    video, audio { display:none; }
  </style>
</head>
<body>
  <div id="ui">
    <p>Your ID: <strong id="myId">…</strong></p>
    <input id="peerIdInput" placeholder="Peer ID" />
    <button id="connectBtn">Connect</button>
    <div id="status">idle</div>
  </div>

  <!-- hidden media elements -->
  <video id="localVideo" autoplay muted playsinline></video>
  <audio id="remoteAudio" autoplay playsinline></audio>

  <!-- PeerJS -->
  <script src="https://cdn.jsdelivr.net/npm/peerjs@1.5.2/dist/peerjs.min.js"></script>

  <!-- Three.js (ESM) -->
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.164.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.164.0/examples/jsm/webxr/ARButton.js';

    // ---------- UI ----------
    const myIdEl = document.getElementById('myId');
    const peerInput = document.getElementById('peerIdInput');
    const connectBtn = document.getElementById('connectBtn');
    const statusEl = document.getElementById('status');

    function setStatus(s){ statusEl.textContent = s; console.log('[status]', s); }

    // ---------- Media (audio only) ----------
    const localVideo = document.getElementById('localVideo');
    const remoteAudio = document.getElementById('remoteAudio');
    let localStream = null;

    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video:false, audio:true });
      localVideo.srcObject = localStream; // keep mic alive
      setStatus('mic ready');
    } catch (e) {
      alert('Microphone permission required. ' + e);
      throw e;
    }

    // ---------- PeerJS ----------
    const dune = ["Arrakis","Fremen","Sietch","ShaiHulud","Spice","BeneGesserit","Kwizatz","Harkonnen","Atreides","MuadDib"];
    const ng = ["Lagos","Abuja","Kano","Ibadan","PortHarcourt","Enugu","Kaduna","Jos","Benin","Yola"];
    const randId = () => `${dune[Math.floor(Math.random()*dune.length)]}-${ng[Math.floor(Math.random()*ng.length)]}-${Math.floor(Math.random()*1000)}`;

    // Add your TURN in production.
    // const peer = new Peer(randId(), { config: { iceServers: [{urls:'stun:stun.l.google.com:19302'}, {urls:'turn:YOUR_TURN', username:'user', credential:'pass'}] }});
    const peer = new Peer(randId()); // PeerJS cloud STUN only

    let dataConn = null;
    let mediaCall = null;

    peer.on('open', id => { myIdEl.textContent = id; setStatus('peer ready'); });
    peer.on('error', err => setStatus('peer error: ' + err));

    // Incoming data channel
    peer.on('connection', conn => {
      dataConn = conn;
      wireDataConn();
    });

    // Incoming media call
    peer.on('call', call => {
      mediaCall = call;
      call.answer(localStream);
      call.on('stream', s => {
        remoteAudio.srcObject = s;
        remoteAudio.play().catch(()=>{ /* unlock after AR button click */ });
        setStatus('audio connected');
      });
    });

    connectBtn.onclick = () => {
      const remoteId = peerInput.value.trim();
      if(!remoteId){ alert('Enter Peer ID'); return; }

      // Data channel
      dataConn = peer.connect(remoteId, { reliable: true });
      wireDataConn();

      // Media call (audio)
      mediaCall = peer.call(remoteId, localStream);
      mediaCall.on('stream', s => {
        remoteAudio.srcObject = s;
        remoteAudio.play().catch(()=>{ /* unlock after AR button click */ });
        setStatus('audio connected');
      });
    };

    function wireDataConn(){
      setStatus('signaling…');
      dataConn.on('open', () => {
        setStatus('data channel open');
        // Announce color preference immediately
        dataConn.send({ type:'hello', wantPeerCubeColor: myDesiredPeerColor });
      });
      dataConn.on('data', msg => handlePeerMsg(msg));
      dataConn.on('close', ()=> setStatus('data channel closed'));
      dataConn.on('error', e => setStatus('data channel error: '+e));
    }

    // ---------- Three.js + WebXR ----------
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.01, 20);
    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    scene.add(new THREE.HemisphereLight(0xffffff, 0x444466, 1.0));

    // Cube the *peer* controls on this device
    const peerCubeMat = new THREE.MeshStandardMaterial({ color: 'white' });
    const peerCube = new THREE.Mesh(new THREE.BoxGeometry(0.18,0.18,0.18), peerCubeMat);
    peerCube.visible = false;
    scene.add(peerCube);

    // Local desired color for how the peer should render your cube on their device.
    // Phone A: use #red in URL. Phone B: default green.
    const myDesiredPeerColor = (location.hash.replace('#','') === 'red') ? 'red' : 'green';

    // Hit-test setup
    let xrRefSpace = null;
    let hitTestSource = null;

    // Create AR button directly on body with checks
    ensureARButton();

    function ensureARButton(){
      if (!('xr' in navigator)) {
        setStatus('WebXR not available');
        showManualARUnavailable();
        return;
      }
      navigator.xr.isSessionSupported('immersive-ar').then((ok) => {
        if (!ok) {
          setStatus('immersive-ar not supported');
          showManualARUnavailable();
          return;
        }
        const btn = ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] });
        btn.style.zIndex = '20';
        btn.style.position = 'fixed';
        btn.style.right = '12px';
        btn.style.top = '12px';
        document.body.appendChild(btn);

        // Gesture unlock for audio and resend color
        btn.addEventListener('click', () => {
          try { remoteAudio.play(); } catch(_) {}
          if (dataConn && dataConn.open) {
            dataConn.send({ type:'hello', wantPeerCubeColor: myDesiredPeerColor });
          }
        });
      });
    }

    function showManualARUnavailable(){
      const warn = document.createElement('div');
      warn.style.cssText = 'position:fixed;right:12px;top:12px;z-index:20;background:#ffe0e0;padding:8px 10px;border-radius:6px;font:12px system-ui';
      warn.textContent = 'AR unsupported. Use Chrome on Android with ARCore and HTTPS.';
      document.body.appendChild(warn);
    }

    renderer.xr.addEventListener('sessionstart', async () => {
      const session = renderer.xr.getSession();
      xrRefSpace = await session.requestReferenceSpace('local');
      const viewerSpace = await session.requestReferenceSpace('viewer');
      hitTestSource = await session.requestHitTestSource({ space: viewerSpace });

      session.addEventListener('select', onSelect);
      setStatus('AR running. Tap to place peer cube remotely.');
    });

    renderer.xr.addEventListener('sessionend', () => {
      hitTestSource = null;
      xrRefSpace = null;
      setStatus('AR session ended');
    });

    async function onSelect(ev){
      if (!hitTestSource || !xrRefSpace) return;

      const frame = ev.frame;
      const hitResults = frame.getHitTestResults(hitTestSource);
      if (hitResults.length === 0) return;

      const hitPose = hitResults[0].getPose(xrRefSpace);
      const p = [hitPose.transform.position.x, hitPose.transform.position.y, hitPose.transform.position.z];
      const q = [
        hitPose.transform.orientation.x,
        hitPose.transform.orientation.y,
        hitPose.transform.orientation.z,
        hitPose.transform.orientation.w
      ];
      if (dataConn && dataConn.open) {
        dataConn.send({ type:'pose', position:p, quaternion:q, scale:1.0 });
        dataConn.send({ type:'hello', wantPeerCubeColor: myDesiredPeerColor });
        setStatus('sent pose to peer');
      } else {
        setStatus('no data channel');
      }
    }

    function handlePeerMsg(msg){
      if (msg?.type === 'hello') {
        const c = msg.wantPeerCubeColor || 'green';
        peerCube.material.color.set(c);
        peerCube.visible = true;
        setStatus('peer color: ' + c);
      }
      if (msg?.type === 'pose') {
        peerCube.visible = true;
        peerCube.position.fromArray(msg.position || [0,0,-1]);
        if (Array.isArray(msg.quaternion) && msg.quaternion.length === 4) {
          peerCube.quaternion.set(msg.quaternion[0], msg.quaternion[1], msg.quaternion[2], msg.quaternion[3]);
        }
        const s = msg.scale || 1;
        peerCube.scale.setScalar(s);
        setStatus('peer cube placed');
      }
    }

    // Render loop
    renderer.setAnimationLoop(() => {
      renderer.render(scene, camera);
    });

    // Resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
